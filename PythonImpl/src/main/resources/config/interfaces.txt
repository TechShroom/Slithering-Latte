# based off of https://docs.python.org/3/reference/datamodel.html


# all objects
# id is special cased to a static lookup
# type is mapped to getClass
-i METHOD -n Deletable -p __del__ -t void;
# str is mapped to toString
-i METHOD -n Representable -p __repr__ -t String;
-i METHOD -n ConvertableToBytes -p __bytes__ -t byte[];
-i METHOD -n Formattable -p __format__ -t String -m String:formatSpec;
-i METHOD -n Comparable
    LT -p __lt__ -a lessThan -t boolean -m T:other -g T --share-generic;
-i METHOD -n Comparable
    LE -p __le__ -a lessThanOrEqualTo -t boolean -m T:other -g T --share-generic;
-i METHOD -n Comparable
    EQ -p __eq__ -a equalTo -t boolean -m T:other -g T --share-generic;
-i METHOD -n Comparable
    NE -p __ne__ -a notEquals -t boolean -m T:other -g T --share-generic;
-i METHOD -n Comparable
    GT -p __gt__ -a greaterThan -t boolean -m T:other -g T --share-generic;
-i METHOD -n Comparable
    GE -p __ge__ -a greaterThanOrEqualTo -t boolean -m T:other -g T --share-generic;
# hash is mapped to hashCode
-i METHOD -n ConvertableToBool -p __bool__ -t boolean;
-i METHOD -n RegularAttributeProvider -p __getattribute__ -t Object -m String:name;
-i METHOD -n AttributeStorage -p __setattr__ -t Object -m String:name,String:value;
-i METHOD -n AttributeDestructor -p __delattr__ -t Object -m String:name;
-i METHOD -n AttributeSequenceProvider -p __dir__ -t Iterable -g String;
-i ATTRIBUTE -n AttributeSlots -p __slots__ -t List -g String;
-i ATTRIBUTE -n AttributeDictionaryAttribute -p __dict__ -w -t java.util.Map -g String,Object;
-i MIX -n PythonObject -p object -s Deletable,Representable,ConvertableToBytes,
                             ComparableMixin<T>,ConvertableToBool,
                             RegularAttributeProvider,AttributeStorage,AttributeDestructor,
                             AttributeSequenceProvider,AttributeSlots,
                             AttributeDictionaryAttribute -g T;

# some random stuff you can mixin
-i METHOD -n MissingAttributeProvider -p __getattr__ -t Object -m String:name;

# descriptors are fun for the whole family
# but hard-coded since they're simple

# callable objects
-i ATTRIBUTE -n DocumentationAttribute -p __doc__ -w -t String;
-i ATTRIBUTE -n NameAttribute -p __name__ -w -t String;
-i ATTRIBUTE -n QualifiedNameAttribute -p __qualname__ -w -t String;
-i ATTRIBUTE -n ModuleNameAttribute -p __module__ -w -t String;
-i ATTRIBUTE -n DefaultArgsAttribute -p __defaults__ -w -t Tuple;
-i ATTRIBUTE -n CompiledCodeAttribute -p __code__ -w -t String;
-i ATTRIBUTE -n GlobalsAttribute -p __global__ -t java.util.Map -g String,Object;
-i ATTRIBUTE -n ClosureVariablesAttribute -p __closure__ -t Tuple;
-i ATTRIBUTE -n ParameterAnnotationsAttribute -p __annotations__ -w -t java.util.Map -g String,
                                                                                        Object;
-i ATTRIBUTE -n KeywordDefaultsAttribute -p __kwdefaults__ -w -t java.util.Map -g String,Object;
-i MIX -n CallableType -s DocumentationAttribute,NameAttribute,QualifiedNameAttribute,
                   ModuleNameAttribute,DefaultArgsAttribute,CompiledCodeAttribute,
                   GlobalsAttribute,AttributeDictionaryAttribute,
                   ClosureVariablesAttribute,ParameterAnnotationsAttribute,
                   KeywordDefaultsAttribute;

# metaclass
-i METHOD -n NamespacePreparer -p __prepare__ -t Map -g String,Object -m String:
                                                           name,List<String>:bases,
                                                           Map<String|Object>:
                                                           kwargs@KeywordArgs -c return%20
                                                           new%20java.util.HashMap<>();
-i METHOD -n InstanceCheck -p __instancecheck__ -t boolean -m String:instance;
-i METHOD -n SubclassCheck -p __subclasscheck__ -t boolean -m String:subclass;
-i MIX -n Metaclass -s NamespacePreparer,InstanceCheck,SubclassCheck,CallableType;

# instance methods, or bound methods (really bound callables)
-i ATTRIBUTE -n BoundSelfParameterAttribute -p __self__ -t Object;
-i ATTRIBUTE -n BoundFunctionAttribute -p __func__ -t Object; # actually Function
-i MIX -n BoundCallableType -s BoundSelfParameterAttribute,BoundFunctionAttribute,CallableType;

# builtins
-i MIX -n BuiltinMethodType -s DocumentationAttribute,NameAttribute,ModuleNameAttribute;

# bound builtins
-i MIX -n BoundBuiltinMethodType -s BuiltinMethodType,BoundSelfParameterAttribute;

# classes...sorta?
# __new__ is static
# __init__ is mapped to the constructor

# callable classes
# covered by methods...probably?

# modules
-i ATTRIBUTE -n FileSource -p __file__ -t String;
-i MIX -n Module -s AttributeDictionaryAttribute,NameAttribute,DocumentationAttribute,FileSource;
